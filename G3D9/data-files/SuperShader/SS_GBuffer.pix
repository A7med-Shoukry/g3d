// -*- c++ -*-
/** \file SS_GBuffer.pix 
    \author Morgan McGuire, http://graphics.cs.williams.edu*/

// This shader expects a prefix attached at runtime in SuperShader.cpp

/** Texture coordinate */
varying vec2 texCoord;

varying vec3 wsPosition;

// Material
#ifdef SPECULARCONSTANT
    uniform vec4        specularConstant;
#endif

#ifdef SPECULARMAP
    uniform sampler2D   specularMap;
#endif

#ifdef LAMBERTIANCONSTANT
    uniform vec4        lambertianConstant;
#endif

#ifdef LAMBERTIANMAP
    uniform sampler2D   lambertianMap;
#endif

#ifdef EMISSIVECONSTANT
    uniform vec3        emissiveConstant;
#endif

#ifdef EMISSIVEMAP
    uniform sampler2D   emissiveMap;
#endif

#ifdef TRANSMISSIVECONSTANT
    // Index of refraction / 24 is in the alpha value
    uniform vec4        transmissiveConstant;
#endif

#ifdef TRANSMITMAP
    uniform sampler2D   transmissiveMap;
#endif

#ifdef CS_POSITION_CHANGE
    varying vec3 csPrevPosition;
#endif

#ifdef SS_POSITION_CHANGE
    // Homogeneous space
    varying vec4 hsPrevPosition;
#endif

float backside = (gl_FrontFacing == g3d_InvertY) ?  1.0 : -1.0;

#ifdef NORMALBUMPMAP
#   if (PARALLAXSTEPS > 0)
        /** Multiplier for bump map.  Typically on the range [0, 0.05]
          This increases with texture scale and bump height. */
        uniform float       bumpMapScale;

        /** How high is the 0-level of the bump map? On the range [0, 1] */
        uniform float       bumpMapBias;

        /** Un-normalized (interpolated) tangent space eye vector */
        varying vec3        _tsE;
#   endif    
    /** xyz = normal, w = bump height */
    uniform sampler2D   normalBumpMap;
    varying vec3        tan_X, tan_Y;
#endif
varying vec3        tan_Z;

/** Index of refraction / 24.0 */
uniform float       normalizedIndexOfRefraction;

#include "SS_BumpMap.pix"
#line 72

void main() {    
    vec2 offsetTexCoord;
    vec3 wsN;

    applyBumpMap(wsN, offsetTexCoord);

    //////////////////////// MATERIAL //////////////////////////////

    float alpha;
    vec3 lambertianColor;

    // We have to always read alpha because there may be alpha testing
#   if defined(LAMBERTIANCONSTANT) || defined(LAMBERTIANMAP)
    {
        vec4 temp = 
#       ifdef LAMBERTIANCONSTANT
            lambertianConstant
#           ifdef LAMBERTIANMAP
                * texture2D(lambertianMap, offsetTexCoord)
#           endif
#       else
            texture2D(lambertianMap, offsetTexCoord)
#       endif
        ;
        lambertianColor = temp.rgb;
        alpha = temp.a;
    }
#   else
        lambertianColor = vec3(0.0);
        alpha = 1.0;
#   endif

    // TODO: explict alpha test to discard; we can't rely on the hardware for it
    // because the FBO specification doesn't say how it works.

#   ifdef LAMBERTIAN
        LAMBERTIAN.rgb = lambertianColor;
#   endif

#   ifdef GLOSSY
        GLOSSY.rgba =
#       if defined(SPECULARCONSTANT) || defined(SPECULARMAP)     
#           ifdef SPECULARCONSTANT
                specularConstant
#               ifdef SPECULARMAP
                    * texture2D(specularMap, offsetTexCoord)
#               endif
#           else
                texture2D(specularMap, offsetTexCoord)
#           endif
#       else
            vec4(0.0)
#       endif
        ;
#   endif


#   ifdef EMISSIVE
        EMISSIVE.rgb =
#       if defined(EMISSIVECONSTANT) || defined(EMISSIVEMAP)     
#           ifdef EMISSIVECONSTANT
                emissiveConstant
#               ifdef EMISSIVEMAP
                    * texture2D(emissiveMap, offsetTexCoord).rgb
#               endif
#           else
                texture2D(emissiveMap, offsetTexCoord).rgb
#           endif
#       else
            vec3(0.0)
#       endif
        ;
#   endif



#   ifdef TRANSMISSIVE
        TRANSMISSIVE.rgb =
#       if defined(TRANSMISSIVECONSTANT) || defined(TRANSMISSIVEMAP)     
#           ifdef TRANSMISSIVECONSTANT
                transmissiveConstant
#               ifdef TRANSMISSIVEMAP
                    * texture2D(transmissiveMap, offsetTexCoord).rgb
#               endif
#           else
                vec4(texture2D(transmissiveMap, offsetTexCoord).rgb
#           endif
#       else
            vec3(0.0, 0.0, 0.0)
#       endif
        ;
#   endif

    ///////////////////////// NORMALS //////////////////////////////
#   ifdef WS_NORMAL
        WS_NORMAL.xyz = wsN * 0.5 + vec3(0.5);
#   endif

#   ifdef CS_NORMAL
        CS_NORMAL.xyz = (g3d_WorldToCameraMatrix * vec4(wsN, 0.0)).xyz * 0.5 + vec3(0.5);
#   endif

#   if defined(WS_FACE_NORMAL) || (CS_FACE_NORMAL)
        vec3 wsFaceNormal = normalize(cross(dFdy(wsPosition), dFdx(wsPosition)));
#   endif
    // For simplicity, all normals are encoded regardless of format.
#   ifdef WS_FACE_NORMAL
        WS_FACE_NORMAL.xyz = wsFaceNormal * 0.5 + vec3(0.5);
#   endif

#   ifdef CS_FACE_NORMAL
        CS_FACE_NORMAL.xyz = (g3d_WorldToCameraMatrix * vec4(wsFaceNormal, 0.0)).xyz * 0.5 + vec3(0.5);
#   endif

    //////////////////////// POSITIONS /////////////////////////////
    // NVIDIA drivers miscompile this unless we write WS_POSITION after the normals

#   ifdef WS_POSITION
        WS_POSITION.xyz = wsPosition;
#   endif

#   if defined(CS_POSITION) || defined(CS_POSITION_CHANGE) || defined(SS_POSITION_CHANGE)
        vec3 csPosition = (g3d_WorldToCameraMatrix * vec4(wsPosition, 1.0)).xyz;
#   endif

#   ifdef CS_POSITION
        CS_POSITION.xyz = csPosition;
#   endif

#   ifdef CS_Z
        CS_Z.r = dot(g3d_WorldToCameraMatrix[3], vec4(wsPosition, 1.0));
#   endif

#   ifdef CS_POSITION_CHANGE
        CS_POSITION_CHANGE = csPosition - csPrevPosition;
#   endif

#   ifdef SS_POSITION_CHANGE
        vec2 ssPrevPosition = hsPrevPosition.xy / hsPrevPosition.w;
        SS_POSITION_CHANGE = gl_FragCoord.xy - ssPrevPosition;
#   endif
}
